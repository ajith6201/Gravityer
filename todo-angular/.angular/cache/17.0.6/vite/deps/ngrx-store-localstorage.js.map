{
  "version": 3,
  "sources": ["../../../../../node_modules/deepmerge/dist/cjs.js", "../../../../../node_modules/ngrx-store-localstorage/fesm2022/ngrx-store-localstorage.mjs"],
  "sourcesContent": ["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "import deepmerge from 'deepmerge';\n\n// Cannot import from the @ngrx/store package due to a module resolution issue.\n// See Issue #206.\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n// correctly parse dates from local storage\nconst dateReviver = (_key, value) => {\n    if (typeof value === 'string' && detectDate.test(value)) {\n        return new Date(value);\n    }\n    return value;\n};\nconst dummyReviver = (_key, value) => value;\nconst checkIsBrowserEnv = () => {\n    return typeof window !== 'undefined';\n};\nconst validateStateKeys = (keys) => {\n    return keys.map((key) => {\n        let attr = key;\n        if (typeof key === 'object') {\n            attr = Object.keys(key)[0];\n        }\n        if (typeof attr !== 'string') {\n            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);\n        }\n        return key;\n    });\n};\nconst rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {\n    return keys.reduce((acc, curr) => {\n        let key = curr;\n        let reviver = restoreDates ? dateReviver : dummyReviver;\n        let deserialize;\n        let decrypt;\n        if (typeof key === 'object') {\n            key = Object.keys(key)[0];\n            // use the custom reviver function\n            if (typeof curr[key] === 'function') {\n                reviver = curr[key];\n            }\n            else {\n                // use custom reviver function if available\n                if (curr[key].reviver) {\n                    reviver = curr[key].reviver;\n                }\n                // use custom serialize function if available\n                if (curr[key].deserialize) {\n                    deserialize = curr[key].deserialize;\n                }\n            }\n            // Ensure that encrypt and decrypt functions are both present\n            if (curr[key].encrypt && curr[key].decrypt) {\n                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n                    decrypt = curr[key].decrypt;\n                }\n                else {\n                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n                }\n            }\n            else if (curr[key].encrypt || curr[key].decrypt) {\n                // Let know that one of the encryption functions is not provided\n                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n            }\n        }\n        if (storage !== undefined) {\n            let stateSlice = storage.getItem(storageKeySerializer(key));\n            if (stateSlice) {\n                // Use provided decrypt function\n                if (decrypt) {\n                    stateSlice = decrypt(stateSlice);\n                }\n                const isObjectRegex = new RegExp('{|\\\\[');\n                let raw = stateSlice;\n                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n                    raw = JSON.parse(stateSlice, reviver);\n                }\n                return Object.assign({}, acc, {\n                    [key]: deserialize ? deserialize(raw) : raw,\n                });\n            }\n        }\n        return acc;\n    }, {});\n};\n// Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\nfunction createStateSlice(existingSlice, filter) {\n    return filter.reduce((memo, attr) => {\n        if (typeof attr === 'string' || typeof attr === 'number') {\n            const value = existingSlice?.[attr];\n            if (value !== undefined) {\n                memo[attr] = value;\n            }\n        }\n        else {\n            for (const key in attr) {\n                if (Object.prototype.hasOwnProperty.call(attr, key)) {\n                    const element = attr[key];\n                    memo[key] = createStateSlice(existingSlice[key], element);\n                }\n            }\n        }\n        return memo;\n    }, {});\n}\nconst syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {\n    if (syncCondition) {\n        try {\n            if (syncCondition(state) !== true) {\n                return;\n            }\n        }\n        catch (e) {\n            // Treat TypeError as do not sync\n            if (e instanceof TypeError) {\n                return;\n            }\n            throw e;\n        }\n    }\n    keys.forEach((key) => {\n        let stateSlice = state[key];\n        let replacer;\n        let space;\n        let encrypt;\n        if (typeof key === 'object') {\n            let name = Object.keys(key)[0];\n            stateSlice = state[name];\n            if (typeof stateSlice !== 'undefined' && key[name]) {\n                // use serialize function if specified.\n                if (key[name].serialize) {\n                    stateSlice = key[name].serialize(stateSlice);\n                }\n                else {\n                    // if serialize function is not specified filter on fields if an array has been provided.\n                    let filter;\n                    if (key[name].reduce) {\n                        filter = key[name];\n                    }\n                    else if (key[name].filter) {\n                        filter = key[name].filter;\n                    }\n                    if (filter) {\n                        stateSlice = createStateSlice(stateSlice, filter);\n                    }\n                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n                    if (key[name].encrypt && key[name].decrypt) {\n                        if (typeof key[name].encrypt === 'function') {\n                            encrypt = key[name].encrypt;\n                        }\n                    }\n                    else if (key[name].encrypt || key[name].decrypt) {\n                        // If one of those is not present, then let know that one is missing\n                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);\n                    }\n                }\n                /*\n          Replacer and space arguments to pass to JSON.stringify.\n          If these fields don't exist, undefined will be passed.\n        */\n                replacer = key[name].replacer;\n                space = key[name].space;\n            }\n            key = name;\n        }\n        if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n            try {\n                if (encrypt) {\n                    // ensure that a string message is passed\n                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n                }\n                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n            }\n            catch (e) {\n                console.warn('Unable to save state to localStorage:', e);\n            }\n        }\n        else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {\n            try {\n                storage.removeItem(storageKeySerializer(key));\n            }\n            catch (e) {\n                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n            }\n        }\n    });\n};\n// Default merge strategy is a full deep merge.\nconst defaultMergeReducer = (state, rehydratedState, action) => {\n    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;\n        const options = {\n            arrayMerge: overwriteMerge,\n        };\n        state = deepmerge(state, rehydratedState, options);\n    }\n    return state;\n};\nconst localStorageSync = (config) => (reducer) => {\n    if ((config.storage === undefined && !config.checkStorageAvailability) ||\n        (config.checkStorageAvailability && checkIsBrowserEnv())) {\n        config.storage = localStorage || window.localStorage;\n    }\n    if (config.storageKeySerializer === undefined) {\n        config.storageKeySerializer = (key) => key;\n    }\n    if (config.restoreDates === undefined) {\n        config.restoreDates = true;\n    }\n    // Use default merge reducer.\n    let mergeReducer = config.mergeReducer;\n    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n        mergeReducer = defaultMergeReducer;\n    }\n    const stateKeys = validateStateKeys(config.keys);\n    const rehydratedState = config.rehydrate\n        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)\n        : undefined;\n    return function (state, action) {\n        let nextState;\n        // If state arrives undefined, we need to let it through the supplied reducer\n        // in order to get a complete state as defined by user\n        if (action.type === INIT_ACTION && !state) {\n            nextState = reducer(state, action);\n        }\n        else {\n            nextState = { ...state };\n        }\n        // Merge the store state with the rehydrated state using\n        // either a user-defined reducer or the default.\n        nextState = mergeReducer(nextState, rehydratedState, action);\n        nextState = reducer(nextState, action);\n        if (action.type !== INIT_ACTION) {\n            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n        }\n        return nextState;\n    };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate };\n\n"],
  "mappings": "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",
  "names": ["isMergeableObject", "deepmerge", "options", "deepmerge"]
}
